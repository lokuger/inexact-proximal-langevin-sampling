#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan 26 20:39:11 2023

@author: lorenzkuger
"""

import numpy as np
from numpy.random import default_rng
import matplotlib.pyplot as plt
import sys, getopt, os
#from time import time
from skimage import io, transform

from inexact_pgla import inexact_pgla
from ista import ista
import potentials as pot
import distributions as pds

#%% initial parameters: test image, computation settings etc.
params = {
    'iterations': 10000,
    'blurtype': 'uniform',
    'bandwidth': 3,
    'mean_counts': 100,
    'mean_bg':  1,
    'log_epsilon': -2.0,
    'iter_prox': np.Inf,
    'efficient': True,
    'verbose': True,
    }

#%% auxiliary functions
def blur_unif(n, b):
    """compute the blur operator a, its transpose a.t and the maximum eigenvalue 
    of ata.
    Carfeul, this assumes a quadratic n x n image
    blur length b must be integer and << n to prevent severe ill-posedness"""
    h = np.ones((1, b))
    lh = h.shape[1]
    h = h / np.sum(h)
    h = np.pad(h, ((0,0), (0, n-b)), mode='constant')
    h = np.roll(h, -int((lh-1)/2))
    h = np.matmul(h.T, h)
    H_FFT = np.fft.fft2(h)
    HC_FFT = np.conj(H_FFT)
    a = lambda x : np.real(np.fft.ifft2(H_FFT * np.fft.fft2(x)))
    at = lambda x : np.real(np.fft.ifft2(HC_FFT * np.fft.fft2(x)))
    ata = lambda x : np.real(np.fft.ifft2(H_FFT * HC_FFT * np.fft.fft2(x)))
    max_eigval = power_method(ata, n, 1e-4, int(1e3))
    return a,at,max_eigval

def blur_gauss(n, sigma):
    """compute the blur operator a, its transpose a.t and the maximum eigenvalue 
    of ata.
    Carfeul, this assumes a quadratic n x n image, with n even
    blur standard dev is assumed to be given in #pixels"""
    t = np.arange(-n/2+1,n/2+1)
    h = np.exp(-t**2/(2*sigma**2))
    h = h / np.sum(h)
    h = np.roll(h, -int(n/2)+1)
    h = h[np.newaxis,:] * h[:,np.newaxis]
    H_FFT = np.fft.fft2(h)
    HC_FFT = np.conj(H_FFT)
    a = lambda x : np.real(np.fft.ifft2(H_FFT * np.fft.fft2(x)))
    at = lambda x : np.real(np.fft.ifft2(HC_FFT * np.fft.fft2(x)))
    ata = lambda x : np.real(np.fft.ifft2(H_FFT * HC_FFT * np.fft.fft2(x)))
    max_eigval = power_method(ata, n, 1e-4, int(1e3))
    return a,at,max_eigval
    
def power_method(ata, n, tol, max_iter, verbose=False):
    """power method to compute the maximum eigenvalue of the linear op at*a"""
    x = np.random.normal(size=(n,n))
    x = x/np.linalg.norm(x.ravel())
    val, val_old = 1, 1
    for k in range(max_iter):
        x = ata(x)
        val = np.linalg.norm(x.ravel())
        rel_var = np.abs(val-val_old)/val_old
        val_old = val
        x = x/val
        if rel_var < tol:
            break
    return val

def my_imsave(im, filename, vmin=-0.02, vmax=1.02):
    im = np.clip(im,vmin,vmax)
    im = np.clip((im-vmin)/(vmax-vmin) * 256,0,255).astype('uint8')
    io.imsave(filename, im)
    
def my_imshow(im, label, vmin=-0.02, vmax=1.02, cbar=False):
    fig = plt.figure()
    plt.subplots_adjust(left = 0, right = 1, top = 1, bottom = 0)
    q = plt.imshow(im, cmap='Greys_r', vmin=vmin, vmax=vmax)
    if cbar: plt.colorbar()
    plt.axis('off')
    plt.show()

#%% Main method - generate results directories
def main():
    # result_root = params['result_root']
    
    # test_image_name = params['testfile_path'].split('/')[-1].split('.')[0]
    # accuracy = 'log-epsilon{}'.format(params['log_epsilon'])
    # file_specifier = '{}_{}_{}-samples'.format(test_image_name,accuracy,params['iterations'])
    # results_file = result_root+'/'+file_specifier+'.npy'
    # mmse_file = result_root+'/mmse_'+file_specifier+'.png'
    # logstd_file = result_root+'/logstd_'+file_specifier+'.png' 
        
    #%% Ground truth
    # results_file = results_dir+'/result_images.npy' 
    rng = default_rng(1392)
    verb = params['verbose']
    # try:
    #     x = io.imread(params['testfile_path'],as_gray=True).astype(float)
    # except FileNotFoundError:
    #     print('Provided test image did not exist under that path, aborting.')
    #     sys.exit()
    # # handle images that are too large
    # Nmax = 256
    # if x.shape[0] > Nmax or x.shape[1] > Nmax: x = transform.resize(x, (Nmax,Nmax))
    
    # chess test image
    n,t = 64, 16
    x = np.zeros((n,n))
    for i in np.arange(n):
        for j in np.arange(n):
            if (i//t)%2 == (j//t)%2:
                x[i,j] = 1
    
    x = x-np.min(x)
    x = x/np.max(x)

    # assume quadratic images
    n = x.shape[0]
    
    #%% Forward model & corrupted data
    blur_width = params['bandwidth']
    if params['blurtype'] == 'gaussian':
        a,at,max_ev_ata = blur_gauss(n,blur_width) 
    elif params['blurtype'] == 'uniform':
        a,at,max_ev_ata = blur_unif(n,blur_width)
    elif params['blurtype'] == 'none':
        a,at,max_ev_ata = lambda x : x, lambda x : x, 1
    else: print('Unknown blur type, aborting'); sys.exit()
    
    scale = params['mean_counts']
    scale_bg = params['mean_bg']

    y = rng.poisson(scale*a(x)+scale_bg)
    b = np.ones_like(y)*scale_bg
    
    # show ground truth and corrupted image
    my_imshow(x,'ground truth',cbar=True)
    my_imshow(y,'noisy image',vmin=0,vmax=np.max(y),cbar=True)

    mu_tv = 1
        
    #%% MAP computation
    # deblur using ISTA on the composite functional f(x)+g(x). The splitting is 
    #       f(x) = KL(Ax+sigma,y) and g(x) = TV(x) + i_R+(x)
    # where KL is Kullback-Leibler, TV total variation and i_R+ indicator of positive orthant.
    # Main challenge is the backtracking of the step sizes since the Lipschitz constant of KL
    # becomes large on the boundary of the admissible set R+^n
    x0 = np.zeros(x.shape)
    tau_ista = ('bt',1)
    n_iter_ista = 100
    f = pot.kl_divergence(y,b,a,at)
    g = pot.total_variation_nonneg(n1=n,n2=n,scale=mu_tv)
    sta = ista(x0, tau_ista, n_iter_ista, f, g, efficient=True)
    
    if verb: sys.stdout.write('Compute MAP - '); sys.stdout.flush()
    u = sta.compute(verbose=True)
    if verb: sys.stdout.write('Done.\n'); sys.stdout.flush()

    rec = u/scale
    my_imshow(rec,'MAP estimate')
    print('MAP: mu_TV = {:.1f};\tPSNR: {:.2f}'.format(mu_tv,10*np.log10(np.max(x)**2/np.mean((rec-x)**2))))
            
    
#%% gather parameters from shell and call main
if __name__ == '__main__':
    main()
    